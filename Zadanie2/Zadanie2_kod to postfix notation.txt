//Converts an infix expression to a postfix expression.

#include <iostream>
#include <string>
#include <math.h>

using namespace std;

template <class typ>

class Stos
{
    typ *elementy; //miejsce na znaki i elementy
    int ile; //do zapamiętania ile jest tych elementów
    
    public: Stos()
    {
        elementy = NULL;
        ile = 0;
    }
    
    Stos(int a)
    {
        elementy = new typ[ile];
        ile = a;
    }
    
    ~Stos()
    {
        delete [] elementy;
        cout << "zwalniam obiekt" << endl;
    }
    
    void put(typ a) //funkcja dodajaca element i zwrocenie go ze szczytu stosu
    {
        typ *ntab = new typ[ile + 1];
        for (int i = 0; i<ile; i++)
        {
            ntab[i]=elementy[i]; //przepisanie elementow ze starej do nowej tablicy
        };
        ntab[ile] = a;//wstawimy nasz nowy element na pozycje ile
        ile = ile + 1; //zwiekszamy rozmiar bo dotychczas tylko wydluzylismy stos
        //brakuje nam jeszcze przepisania, ze stara tablica ma teraz wskazywac na nowa dluzsza tablice i stara tablice usunac
        delete [] elementy; //najpierw musimy wyczyszczic pamiec zaalokowana na elementy a potem na 
        elementy = ntab;
    }
    
    typ get()//funkcja zwracajca element ze stosu
    {
        //zdejmuje ze stosu i zmniejsza rozmiar
        typ wynik = elementy[ile-1]; //ostatni znak z obecnej tablicy pobieramy i go potem zwrócimy
        typ *ntab = new typ[ile - 1]; //stworzenie tablicy o jeden mniejszej niz stos
        for (int i = 0; i<ile-1; i++) //przepisujemy elementy do elementu przedostatniego
        {
            ntab[i]=elementy[i];
        };
        
        ile=ile - 1;
        delete [] elementy;
        elementy = ntab;
        return wynik; //zwrócenie wyniku
    }
    
    typ top() //funkcja zwaracająca wierzchołek stosu
    {
        return elementy[ile-1];
    }
    
    bool empty()
    {
        if (ile == 0) {return true;}
        else
        {
            return false;
        }
    }
    
    int size()
    {
        return ile;
    }
    
    void show()
    {
        cout<<"#";
        for(int i=0;i<ile;i++)
        {
            cout<<" "<< elementy[i]<<",";
        }
        cout<<endl;
    }
};

//Function to return precedence of operators
int prec(char c) {
    if(c == '^')
        return 3;
    else if(c == '/' || c=='*')
        return 2;
    else if(c == '+' || c == '-')
        return 1;
    else
        return -1;
}

int isnumber(char a)
{
    if (a == '0'|| a == '1' || a == '2' || a == '3' || a == '4' || a == '5' || a == '6' || a == '7' || a == '8' || a == '9')
    {
        return 1;
    }
    else
    {
        return 0;
    }
}

int isbracket(char a)
{
    if (a == '(' || a == ')')
    {
        return 1;
    }
    else
    {
        return 0;
    }
}

int isoperator (char a)
{
    if(a =='+'|| a == '^'|| a == '/' || a=='*'|| a == '+' || a == '-')
    {
        return 1;
    }
    else
    {
        return 0;
    }
}

int incorrectstring(string a)
{
    int result = 0;
    for (int i = 0; i < a.length(); i++)
    {
        if (
            (a[i] == ' ' && a[i+1] == ' ') || (isoperator(a[i]) == 1 && isoperator(a[i+1]) == 1) || (isbracket(a[i]) == 1 && isbracket(a[i+1]) == 1)
            || (isnumber(a[i]) == 1 && isoperator(a[i+1]) == 1) || (isoperator(a[i]) == 1 && isnumber(a[i+1]) == 1)
            || (isnumber(a[i]) == 1 && isbracket(a[i+1]) == 1) || (isoperator(a[i]) == 1 && isbracket(a[i+1]) == 1)
            )
        {
            result = 1;
        }
        else
        {
            result = result;
        }
    }
    return result;
}

string checknegativeatbegining(string a)
{
    string outtext = "";
    int i = 0;
    while (i < a.length())
    {
        //- 2 
        if(i == 0 && a[0] == '-' && isnumber(a[2]) == 1 && isnumber(a[3]) == 0)
        {
            outtext = outtext + '(' + ' '+ '0' + ' ' + a[0] + ' ' + a[2] + ' ' + ')';
            i = 3;
        }
        //- 22 
        else if(i == 0 && a[0] == '-' && isnumber(a[2]) == 1 && isnumber(a[3]) == 1 && isnumber(a[4]) == 0)
        {
            outtext = outtext + '(' + ' ' + '0'+ ' ' + a[0] + ' ' + a[2] + a[3] + ' ' + ')';
            i = 4;
        }
        //- 222
        else if(i == 0 && a[0] == '-' && isnumber(a[2]) == 1 && isnumber(a[3]) == 1 && isnumber(a[4]) == 1 && isnumber(a[5]) == 0)
        {
            outtext = outtext + '(' + ' ' + '0' + ' ' + a[0] + ' ' + a[2] + a[3] + a[4] + ' ' + ')';
            i = 5;
        }
        //- 2222
        else if(i == 0 && a[0] == '-' && isnumber(a[2]) == 1 && isnumber(a[3]) == 1 && isnumber(a[4]) == 1 && isnumber(a[5]) == 1 && isnumber(a[6]) == 0)
        {
            outtext = outtext + '(' + ' ' + '0' + ' ' + a[0] + ' ' + a[2] + a[3] + a[4] + a[5] + ' ' + ')';
            i = 6;
        }
        //- 22222
        else if(i == 0 && a[0] == '-' && isnumber(a[2]) == 1 && isnumber(a[3]) == 1 && isnumber(a[4]) == 1 && isnumber(a[5]) == 1 && isnumber(a[6]) == 1 && isnumber(a[7]) == 0)
        {
            outtext = outtext + '(' + ' ' + '0' + ' ' + a[0] + ' ' + a[2] + a[3] + a[4] + a[5] + a[6] + ' ' + ')';
            i = 7;
        }
        else
        {
            outtext = outtext + a[i];
            i = i + 1;
        }
    }
    
    return outtext;
}

string checknegativeinsideofstring(string a)
{
    string outstring = "";
    int i = 0;
    while (i < a.length())
    {
        //negative number after left bracket (so something like ( - 3 ))
        if (a[i] == '(' && a[i+2] == '-' && isnumber(a[i+4]) == 1 && a[i + 5] == ' ')
        {
            outstring = outstring + a[i] + ' ' + '(' + ' ' + '0' + ' ' + a[i+2] + a[i+3] + a[i+4] + a[i+5] + ')';
            i = i + 5;
        }
        //( - 33 )
        else if (a[i] == '(' && a[i+2] == '-' && isnumber(a[i+4]) == 1 && isnumber(a[i+5]) == 1 && a[i + 6] == ' ')
        {
            outstring = outstring + a[i] + ' ' + '(' + ' ' + '0' + ' ' + a[i+2] + a[i+3] + a[i+4] + a[i+5] + a[i+6] + ')';
            i = i + 6;
        }
        //( - 333 )
        else if (a[i] == '(' && a[i+2] == '-' && isnumber(a[i+4]) == 1 && isnumber(a[i+5]) == 1 && isnumber(a[i + 6]) == 1 && a[i + 7] == ' ')
        {
            outstring = outstring + a[i] + ' ' + '(' + ' ' + '0' + ' ' + a[i+2] + a[i+3] + a[i+4] + a[i+5] + a[i+6] + a[i+7] + ')';
            i = i + 7;
        }
        //negative number after operator so something like * - 3
        else if (isoperator(a[i]) == 1 && a[i+2] == '-' && isnumber(a[i+4]) == 1 && a[i+5] == ' ')
        {
            outstring = outstring + a[i] + ' ' + '(' + ' ' + '0' + ' ' + a[i+2] + a[i+3] + a[i+4] + a[i+5] + ')';
            i = i + 5;
        }
        else if (isoperator(a[i]) == 1 && a[i+2] == '-' && isnumber(a[i+4]) == 1 && (i+5 == a.length()))
        {
            outstring = outstring + a[i] + ' ' + '(' + ' ' + '0' + ' ' + a[i+2] + a[i+3] + a[i+4] + ' ' + ')';
            i = i + 5;
        }
        else if (isoperator(a[i]) == 1 && a[i+2] == '-' && isnumber(a[i+4]) == 1 && isnumber(a[i+5]) == 1 and a[i+6] == ' ')
        {
            outstring = outstring + a[i] + ' ' + '(' + ' ' + '0' + ' ' + a[i+2] + a[i+3] + a[i+4] + a[i+5] + a[i+6] + ')';
            i = i + 6;
        }
        else if (isoperator(a[i]) == 1 && a[i+2] == '-' && isnumber(a[i+4]) == 1 && isnumber(a[i+5]) == 1 && i+6 == a.length())
        {
            outstring = outstring + a[i] + ' ' + '(' + ' ' + '0' + ' ' + a[i+2] + a[i+3] + a[i+4] + a[i+5] + ' ' + ')';
            i = i + 6;
        }
        else if (isoperator(a[i]) == 1 && a[i+2] == '-' && isnumber(a[i+4]) == 1 && isnumber(a[i+5]) == 1 && isnumber(a[i+6]) == 1 and a[i+7] == ' ')
        {
            outstring = outstring + a[i] + ' ' + '(' + ' ' + '0' + ' ' + a[i+2] + a[i+3] + a[i+4] + a[i+5] + a[i+6] + a[i+7] + ')';
            i = i + 7;
        }
        else if (isoperator(a[i]) == 1 && a[i+2] == '-' && isnumber(a[i+4]) == 1 && isnumber(a[i+5]) == 1 && isnumber(a[i+6]) == 1 && i+7 == a.length())
        {
            outstring = outstring + a[i] + ' ' + '(' + ' ' + '0' + ' ' + a[i+2] + a[i+3] + a[i+4] + a[i+5] + a[i+6] + ' ' + ')';
            i = i + 7;
        }
        else 
        {
            outstring = outstring + a[i];
            i = i + 1;
        }
    }
    
    return outstring;
}

string stringbeautifier(string a)
{
    string outstring = "";
    int i = 0;
    
    while (i < a.length())
    {
        if (isnumber(a[i]) == 1 && isoperator(a[i+1]) == 1)
        {
            outstring = outstring + a[i] + ' ';
            i = i + 1;
        }
        else if (isoperator(a[i]) == 1 && isoperator(a[i+1]) == 1)
        {
            outstring = outstring + a[i] + ' ';
            i = i + 1;
        }
        else if (a[i] == ' ' && a[i+1] == ' ' && a[i+2] == ' ' && a[i+3] != ' ')
        {
            outstring = outstring + a[i];
            i = i + 3;
        }
        else if (a[i] == ' ' && a[i+1] == ' ' && a[i+2] == ' ' && a[i+3] == ' ')
        {
            outstring = outstring + a[i];
            i = i + 4;
        }
        else if (a[i] == ' ' && a[i+1] == ' ' && a[i+2] != ' ')
        {
            outstring = outstring + a[i];
            i = i + 2;
        }
        else if(i == 0 && a[i] == ' ')
        {
            outstring == outstring;
            i = i + 1;
        }
        else
        {
            outstring = outstring + a[i];
            i = i + 1;
        }
    }
    
    return outstring;
}

string infixToPostfix(string intextin)
{
    Stos<char> *wskStos = new Stos<char>(0);
    string outtext = "";
    string intext = checknegativeinsideofstring(checknegativeatbegining(intextin));
    
    for (int i = 0; i < intext.length(); i++)
    {
        char c = intext[i];
        if (c != ' ')
        {
            if(isnumber(c) == 1 && isnumber(intext[i+1]) == 0)
            {
                outtext = outtext + c;
            }
            if (isnumber(c) == 1 && isnumber(intext[i+1]) == 1 && isnumber(intext[i+2]) == 0)
            {
                outtext = outtext + c + intext[i+1];
                i = i + 2;
            }
            if (isnumber(c) == 1 && isnumber(intext[i+1]) == 1 && isnumber(intext[i+2]) == 1)
            {
                outtext = outtext + c + intext[i+1] + intext[i+2];
                i = i + 3;
            }
            if(c == '(')
            {
                wskStos -> put(c);
            }
            if(c == ')') 
            {
			    while(wskStos -> top() != '(')
			    {
			    	outtext += wskStos -> top();
		    		wskStos -> get();
		    	}
		    	wskStos -> get();
	    	}
	    	if (isoperator(c) == 1) 
	    	{
			    while(!wskStos -> empty() && prec(intext[i]) <= prec(wskStos -> top())) 
			    {
			    	outtext += wskStos -> top();
			    	wskStos -> get();
			    }
			    wskStos -> put(c);
		    }
        }
        if (c == ' ')
        {
            outtext =outtext + ' ';
        }
    }
    
    // Pop all the remaining elements from the stack
	while(!wskStos -> empty()) {
		outtext += wskStos -> top();
		wskStos -> get();
	}
    
    string outtext2 = stringbeautifier(outtext);
    
    cout << "Input string presented in postfix notation:"<< outtext2 << "." << endl;
    return outtext;
}

float calculation (float a, float b, char oper)
{
    switch(oper)
	{
		case '+': 
			return a + b;
		case '-': 
			return a - b;
		case '*': 
			return a * b;
		case '/': 
			if (b != 0)
			{
			    return a / b;//dzielenie całkowite    
			}
			else
			{
			    cout << "Division by zero error." << endl;
			    return 0;
			}
		case '^':
		    return pow(a, b);
	}
	cout<<"Incorrect operator error.";
	return 0;
}

//modification of string of digits to number
int str_to_int(string a, int &loc) 
{
	int number = 0;
	while(loc < a.size() && isnumber(a[loc]) == 1)
	{
		//schemat Hornera
		number = number * 10 + a[loc] - '0';
		++loc;
	}
	--loc;
	return number;
}

void reversepolishnotation(string a)
{
    Stos<float> *wskStos = new Stos<float>(0);
    float num1 = 0, num2 = 0;
    
    for (int i = 0; i < a.size(); i++)
    {
        if(isnumber(a[i]) == 1)
        {
            wskStos -> put(str_to_int(a, i));
        }
        else
        {
            if (isoperator(a[i]) == 1)
            {
                if (wskStos -> size() < 2)
                {
                    cout << "Incorrect equation in Reverse Polish Notation." << endl;
                }
                num1 = wskStos -> top();
                wskStos -> get();
                num2 = wskStos -> top();
                wskStos -> get();
                wskStos -> put(calculation(num2, num1, a[i]));
                cout << "num1:" << num1 << ", num2:" << num2 <<", a[i]:" << a[i] << ", wynik:" << wskStos -> top()<< "." << endl;
            }
        }
    }
    
    //if on stack there are less or just 1 element
    if (wskStos -> size() != 1)
    {
        cout << "Incorrect equation in Reverse Polish Notation." << endl;
    }
    
    cout << "Output value from provided input string calculated with usage of infix to postfix transformation and reverse polish notation algorith is equal: " << wskStos -> top() << "."<<endl;
}

int main() {
    
    string input = "- 2 ^ 2 * 2 - 3 * 4 + 2 - 3 ^ ( - 3 )";
    if(incorrectstring(input) == 0)
    {
        cout << "Inserted string:" << input <<"." << endl;
        string exp2 = infixToPostfix(input);
        reversepolishnotation(exp2);
    }
    else
    {
        cout << "Incorrect string. Please ensure that each symbol or number are separated with space." << endl;
    }
}
